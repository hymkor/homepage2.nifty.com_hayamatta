<HTML>
<HEAD>
<TITLE>EMX シングルスレッド C ランタイム DLL の差し変え</TITLE>
<STYLE type="text/css">
<!--
  P{margin-left:3em;margin-right:3em}
  PRE{margin-left:3em;margin-right:3em}
  H1{text-align:center>
-->
</STYLE>
</HEAD>
<BODY>
<H1>差し替え版 EMX シングルスレッド C ランタイム DLL </H1>

<TABLE WIDTH=60% BORDER ALIGN=CENTER>
<TR><TD>
本ドキュメントは、<A HREF="http://hobbes.nmsu.edu/">Hobbes</A><!--
-->にアップロードされている<A
HREF="ftp://hobbes.nmsu.edu/pub/os2/dev/emx/contrib/emx-strt-fix-0.0.2.zip"
>emx-strt-fix-0.0.2.zip</A> の emx/doc/README <!--
-->を、はやまが和訳したものです。自分の作ったシングルスレッドの<!--
-->emx プログラムが、XFree86 とかで動かないとお悩みのソフト作者の<!--
-->の方はお読みになった方がいいかと存じます<!--
-->(訳が結構無茶苦茶なので、できれば原文も読んで欲しいな…なんてね)。
</TD></TR>
</TABLE>


<H2>法的問題</H2>

<P>本プログラムは、作者の元では動作しているが、<!--
-->貴方の下でも動作するものを保証するものではない。
</P>
<P>貴方がパワープラントを動作させていたら、<!--
-->本プログラムを使ってはいけない<!--
-->(貴方が本当にパワープラント等を動作させているのに、<!--
-->PC を使用するような馬鹿者でないと私は信じている)。
</P>

<H2>インストール</H2>

<P>インストールは極めて簡単である。<!--
-->ただ、dll/emxlibcs.dll を emx/dll ディレクトリの emxlibcs.dll の上<!--
-->に上書きするだけである。もし別のプログラムで使われているようなら、<!--
-->ロックを外すツールを使うか、コマンドプロンプトモードでリブート<!--
-->(ALT+F1/C)などしてから、コピーする。当然ながら、その前に旧emxlibcs.dll<!--
-->をバックアップしたいかもしれないが、旧emxlibcs と差し変える emxlibcs <!--
-->の間に何ら差異は見付けられないだろう<EM>(ちょっと超訳)</EM>。
</P>

<H2>説明</H2>

<P>
「こんなもん何で必要なのだ？」貴方は尋ねるかもしれない。<!--
-->ふむ、貴方がただのユーザなら、必要ではない、<!--
-->貴方がインストールしているプログラムが明らかにそれを<!--
-->必要としている場合を除けば。貴方がプログラマーで、emx の<!--
-->開発環境を使用していて、様々な UNIX ソフトウェアを XFree86/2<!--
-->へ移植しているのなら、これは必須である。理由を説明しよう。
</P>
<P>XFree86 の OS/2 の説明にて、我々(OS/2プログラマーのコミュニティー)<!--
-->は、新たな(yet another)非互換性問題に直面した。それは emx の C ラン<!--
-->タイムライブラリのシングルスレッド版とマルチスレッド版を同時使用が<!--
-->できないというものである。XFree86 は基本的に「-Zcrtdll -Zmt」付きで<!--
-->コンパイルされているが故に、貴方の全てのプログラムや DLL は全て<!--
-->「-Zmt」付きでコンパイルしなければならない。しかし、これは<!--
-->ナンセンスである！ほとんどの UNIX プログラムは、本質的に<!--
-->シングルスレッドである上、すでに沢山のコンパイル<!--
-->されたツール(stuff)が存在しているのに、X11 プログラムで<!--
-->それらを使いたい場合には、コンパイルしなおさなくてはならないのだ!?<!--
-->最悪なことに、コンパイル済み PNG.DLL と JPEG.DLL をインストールして<!--
-->しまった人もおり、そして貴方の X11 プログラムはそれらを必要として<!--
-->いるのに、実際にその人が持っているのは シングルスレッド版の DLL <!--
-->なのだ。故に結果は恐しいものである。プログラムはクラッシュし、<!--
-->ユーザは貴方のプログラムはパチもんだと愚痴を垂れ、皆がパニくるのだ。
</P>
<H2>分析</H2>
<P>emxlibcm と emxlibcs のランタイムが何故互換性が無いか理解しませふ。<!--
-->典型的なケースを考えよう。我々は、シングルスレッドライブラリ一つと<!--
-->マルチスレッドな DLL(二番目のDLLがマルチスレッドなCランタイムに<!--
-->リンクしているのが分からない時もある)を用いる、シングルスレッドな<!--
-->プログラムを書いている。
</P>
<PRE>
                                  +---------+
                                  | program |
                                  +----+----+
                                       |
                     +-----------------+-----------------+
                     |                 |                 |
              +------+-------+    +----+----+       +----+----+
              | EMXLIBCS.DLL |<---| DLL one |       | DLL two |
              +--------------+    +---------+       +----+----+
                                                         |
                                                  +------+-------+
                                                  | EMXLIBCM.DLL |
                                                  +--------------+
</PRE>
<P>上の図で、<EM>program</EM>は、シングルスレッドプログラムとして<!--
-->リンクされていて、<EM>DLL one</EM>も同様にシングルスレッド<!--
-->ライブラリである。今、<EM>DLL two</EM>はマルチスレッドDLLであり<!--
-->、これは emxlibcs.dll を使用する。この「ストック」された emx dll<!--
-->でもって、この方式は無惨にも失敗する。というのは、emx C ランタイム<!--
-->の独立性は絶対であり、program は、emxlibcs のランタイムを初期化する<!--
-->が、emxlibcm ランタイムは初期化しないからだ。初期化されていない、<!--
-->二つ目のランタイムはクラッシュするだろう。何とかして、それを初期化<!--
-->したとしても、別の問題にぶちあたる：あるランタイムで作成された<!--
-->オブジェクトのことを、もう一つのランタイムには伝わらないのである。<!--
-->それゆえ、例えば、emxlibcm ライブラリがファイルをオープンし、<!--
-->program へ DLL two 経由で返した場合、program はそのファイル<!--
-->に対し、fream を実行するが、emxlibcs は混乱する。emxlibcs は<!--
-->このファイルオブジェクトについて何も知らないのだ。
</P>
<P>その上、ファイルオブジェクト / ハンドルには、別の非互換性が<!--
-->存在する。メモリーアローケーション(あるランタイムで<!--
-->確保されたメモリが、もう一つのランタイムで解放できない)、<!--
-->例外などである。あるランタイムで作成された、ほとんど全ての永続<!--
-->オブジェクトは、もう一方のランタイムでの互換性が無い。<!--
-->こりゃあ、問題である。
</P>
<H2>解決方法</H2>
<P>何とかして、二つの DLL を互いにバインドするという解決案を提案する。<!--
-->もっと正確に言うと、ある DLL が、もう一つの DLL の薄いラッパーに<!--
-->なりえるのである。幸いなことに、OS/2 は、いわゆる「forwarders」と<!--
-->呼ばれる機能(notion)を持っている。つまり、ある DLL が、<!--
-->以下のようなラップ関数を書かずして、別の DLL に公開関数を<!--
-->転送することができるのである。
</P>
<PRE>
size_t strlen(char *s)
{
   return otherdll_strlen (s);
}
</PRE>
<P>forwarder によって、我々は無料---実行時のコスト無しに、上のような<!--
-->道具仕立てを行うことができるのである。
</P>
<P>さて、疑問がある。どちらのライブラリが主で、どちらが単なるラッパーに<!--
-->であるべきか？ 私がこのプロジェクトを始めた時、シングルスレッドの<!--
-->emxlibcs はあるがままにしておいて、emxlibcs のラッパーとして emxlibcm<!--
-->をマルチスレッドロック加えて作成しようと意図していた(それらを要求<!--
-->する関数はそお多くない)。しかしながら、開発を通じて、二つの事柄を<!--
-->悟った。</P>
<UL>

<LI>emxlibcs はほとんどマルチスレッドである、いや、ほんと。<!--
-->これは emx.dll(核)がそれ自体マルチスレッドだからである。<!--
-->emx.dll は メモリーアローケーション、ファイルハンドル等<!--
-->を担当している。各々のロックはすでに<B>存在している</B>のである。

<LI>emxlibcs が持っている内部関数の中には、マルチスレッド関数で<!--
-->外部から安全に置換できないものがある。<!--
-->この必要な結合は emxlibcs の外部関数リストに単純に漏れていたりする。

<LI>その上、期待しない動作が多すぎるのだ。

</UL>

<P>故に、私は、vice versa にしてしまって、emxlibcs を<!--
-->emxlibcm のラッパーにすることにした。これは、びっくりするほど、<!--
-->簡単にだった。私は単に関数を全て emxlibcm へ、フォワード<!--
-->しなければいけないだけだった。何らはりきる必要もなかった。
</P>

<H2>コスト</H2>

<P>この世界、何事もコストである。しかしながら、場合によっては<!--
-->(我々のケースみたいに)そのコストが実際にはかなり低い時がある。<!--
-->emx.dll がすでにマルチスレッドだったので、シングルスレッド<!--
-->プログラムがマルチスレッドのランタイムを用いるコストは<!--
-->ほとんど零に近い。実際、シングルスレッドであることによる<!--
-->利益を得られる関数は、ごく少数だ。私はここにリストした関数<!--
-->を一つも覚えていない(超訳)。
</P>
<P><B>実際</B>、シングルスレッドプログラム(すなわち、-Zsys 付きで<!--
-->コンパイルしたプログラム)にとって、コストは零である<!--
-->(それらは DLL を用いないからね)。それゆえ、<!--
-->実際スピードを気にするなら、-Zsys を用いて、-Zcrtdll を<!--
-->使わないようにするのだ(これは「ストック」され emx でも<!--
-->同様である)。
</P>
<P>事実、正直に言うと、置き換え版 emxlibcs を用いることで、<!--
-->リソースと、もしかしたら、スピードさえも得られることだろう<!--
-->(客観的に見積ることは難しいので、理屈は純粋に推測だけど)。<!--
-->差し替え版は、はるかに小さい(約200キロのコードが 6キロに<!--
-->置きかわっている)。emxlibcs と emxlibcm の両方別々に確保<!--
-->されるリソースに気を使うことはない。差し替え版を使えば、<!--
-->それらは共有されるのだ。
</P>

<H2>履歴</H2>

<P>省略</P>

<H2>結言</H2>

<P>う〜む、ここで、言えることはそう多くないんだ。<!--
-->コメント、提案、その他、何でも、大歓迎。
</P>
<P>私の手元では、将来的にも EXM のバージョンは、一つのCランタイムに<!--
-->なってるだろうね<!--
-->(一つや二つのフォワードを行う DLL が過去との互換性のために残される<!--
-->だろうけど)<EM>(←かなり超訳)</EM>
</P>

<address>
Andrew Zabolotny &lt;bit@eltech.ru&gt;<BR>
訳 はやまかおる &lt;iyamatta.hayama@nifty.ne.jp&gt;
</address>

</BODY>
</HTML>
